package org.itmo;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.*;

public class Graph {
    private final int V;
    private final ArrayList<Integer>[] adjList;

    Graph(int vertices) {
        this.V = vertices;
        adjList = new ArrayList[vertices];
        for (int i = 0; i < vertices; ++i) {
            adjList[i] = new ArrayList<>();
        }
    }

    void addEdge(int src, int dest) {
        if (!adjList[src].contains(dest)) {
            adjList[src].add(dest);
        }
    }

    public AtomicBooleanArray parallelBFS(int startVertex) {
        final int parallelism = Runtime.getRuntime().availableProcessors();
        final ExecutorService pool = Executors.newFixedThreadPool(parallelism);
        final AtomicBooleanArray visited = new AtomicBooleanArray(V);
        visited.getAndSet(startVertex, true);
        ArrayList<Integer> queue = new ArrayList<>();
        queue.add(startVertex);
        try {
            while (!queue.isEmpty()) {
                // Can't use runnable because of the `pool.invokeAll` signature.
                final List<Callable<List<Integer>>> tasks = new ArrayList<>(parallelism);

                final int frontSize = queue.size();
                final int perTask = (frontSize - 1 + parallelism) / parallelism;

                for (int i_ = 0; i_ < parallelism; i_++) {
                    final int i = i_;
                    tasks.add(() -> {
                        final List<Integer> result = new LinkedList<>();
                        for (int j = 0; j < perTask; ++j) {
                            final int index = i * perTask + j;
                            if (index >= frontSize) {
                                break;
                            }
                            final int v = queue.get(index);
                            for (int u : adjList[v]) {
                                if (!visited.getAndSet(u, true)) {
                                    result.add(u);
                                }
                            }
                        }
                        return result;
                    });
                }
                final List<Future<List<Integer>>> results = pool.invokeAll(tasks);
                queue.clear();
                for (Future<List<Integer>> result : results) {
                    assert result.isDone();
                    queue.addAll(result.get());
                }
            }
        } catch (InterruptedException | ExecutionException e) {
            throw new RuntimeException(e);
        } finally {
            pool.shutdown();
        }
        return visited;
    }

    //Generated by ChatGPT
    boolean[] bfs(int startVertex) {
        boolean[] visited = new boolean[V];

        LinkedList<Integer> queue = new LinkedList<>();

        visited[startVertex] = true;
        queue.add(startVertex);

        while (!queue.isEmpty()) {
            startVertex = queue.poll();

            for (int n : adjList[startVertex]) {
                if (!visited[n]) {
                    visited[n] = true;
                    queue.add(n);
                }
            }
        }
        return visited;
    }

    @Override
    public String toString() {
        final StringBuilder sb = new StringBuilder();
        sb.append(V).append(":");
        for (int v = 0; v < V; v++) {
            for (int u : adjList[v]) {
                sb.append("\n\t").append(v).append(" -> ").append(u);
            }
        }
        return sb.toString();
    }
}
